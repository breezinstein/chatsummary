using System.Text;
namespace Breeze.ChatSummary
{
    // This class represents the main program for retrieving and summarizing messages from a matrix room
    internal class Program : MatrixMessageExtractor
    {
        // Entry point of the program
        private static async Task Main(string[] args)
        {
            MatrixMessageExtractor extractor = new MatrixMessageExtractor();
            IMessageAnalyzer messageAnalyzer = new OllamaAnalyzer();

            DateTime yesterday = DateTime.Now.AddDays(-1);

            Console.WriteLine("Getting Yesterday's Report...");
            var hourlyMessages = await extractor.GetMessagesByHour();
            var groupedMessages = GroupMessagesByAmount(hourlyMessages, 500, yesterday);

            Console.WriteLine("Analyzing Text...");
            Console.WriteLine("Grouping Messages...");
            string output = await AnalyzeMessages(messageAnalyzer, yesterday, groupedMessages);
            Console.WriteLine(output);

            await PostMessage(yesterday, groupedMessages, output);

        }

        private static async Task PostMessage(DateTime yesterday, List<MatrixMessageGroup> groupedMessages, string output)
        {
            Console.WriteLine("Posting to Matrix...");

            //Get user input for posting to matrix confirmation
            Console.WriteLine("Do you want to post this to Matrix? (Y/N)");
            string response = Console.ReadLine();
            if (response.ToLower() == "y")
            {
                IMessagePoster poster = new MatrixMessagePoster();
                output += "\nDISCLAIMER:Please be aware that text generated by AI can be inaccurate!";
                await poster.PostMessageAsync(output);
            }

            else
            {
                Console.WriteLine("Retry Analysis? (Y/N)");
                response = Console.ReadLine();
                if (response.ToLower() == "y")
                {
                    IMessageAnalyzer messageAnalyzer = new OllamaAnalyzer();

                    output = await AnalyzeMessages(messageAnalyzer, yesterday, groupedMessages);
                    Console.WriteLine(output);
                    await PostMessage(yesterday, groupedMessages, output);
                }
            }
        }

        private static async Task<string> AnalyzeMessages(IMessageAnalyzer messageAnalyzer, DateTime yesterday, List<MatrixMessageGroup> groupedMessages)
        {
            string output = $"Summary of {yesterday.Date.ToString("d")}\n";
            output += $"First message at {groupedMessages[0].earliestMessageTimeStamp.ToString("T")}\n";
            output += $"Last message at {groupedMessages[groupedMessages.Count - 1].latestMessageTimeStamp.ToString("T")}\n";
            output += $"Total Messages: {groupedMessages.Sum(x => x.Count)}\n";
            output += "\n";
            foreach (var group in groupedMessages)
            {
                output += $"{group.Count} Messages between {group.duration}\n";
                output += await messageAnalyzer.AnalyzeTextAsync(group.value);
                output += "\n\n";
            }

            return output;
        }

        // Method to combine multiple MatrixMessageGroup objects into a smaller number of MatrixMessageGroup objects by ensuring that each object has a maximum number of messages
        private static List<MatrixMessageGroup> GroupMessagesByAmount(Dictionary<DateTime, MatrixMessageGroup> dictionary, int maxAmountPerEntry, DateTime dateToGroup)
        {
            List<MatrixMessageGroup> groupedMessages = new List<MatrixMessageGroup>();
            MatrixMessageGroup currentGroup = new MatrixMessageGroup();

            foreach (var item in dictionary)
            {
                if (item.Key.Date != dateToGroup.Date)
                {
                    continue;
                }
                if (currentGroup.Count + item.Value.Count <= maxAmountPerEntry)
                {
                    currentGroup = currentGroup + item.Value;
                }
                else
                {
                    groupedMessages.Add(currentGroup);
                    currentGroup = new MatrixMessageGroup();
                    currentGroup = item.Value;
                }
            }
            if (currentGroup.Count > 0)
            {
                groupedMessages.Add(currentGroup);
            }

            foreach (var item in groupedMessages)
            {
                item.UpdateDuration();
            }

            return groupedMessages;

        }

    }
}